// Internal API to talk to the brain.
// This is not relevant for users. Some structures are exposed
// to the developers.

syntax = "proto3";

package karps.core;

import "karps/proto/computation.proto";
import "karps/proto/graph.proto";
import "karps/proto/spark.proto";
import "tensorflow/core/framework/graph.proto";

// The names of the different compiling phases, in order of action.
// Note that the numbering itself is not relevant, just the order of
// the description here.
enum CompilingPhase {
    // Here is the most detailed explanation of what is happening inside the
    // Karps compiler.

    // Current max: 11

    // The initial graph, as received and parsed.
    // A number of checks have happened already at that point.
    INITIAL = 0;

    // Nodes that are not reachable from the target outputs are removed.
    REMOVE_UNREACHABLE = 1;

    // ****** Replace high level structural constructs *****

    // Removes all references to broadcasts between observables.
    // Broadcasting is convenient to express dependencies between observables (on the
    // client side), but it needs to be replaced
    // by lower-level operatorns when doing functional flattening.
    REMOVE_OBSERVABLE_BROADCASTS = 10;

    // Information about data sources (time stamps) is inserted into the relevant graph
    // nodes.
    DATA_SOURCE_INSERTION = 2;

    // Observables that have been computed already are replaced by pointers
    // to existing paths.
    POINTER_SWAP_1 = 3;

    // Parallel aggregations are merged into single aggregations.
    MERGE_AGGREGATIONS = 7;

    // Special case for aggregations and transforms that happens to be common:
    //    agg1      agg2
    //    trans1    /
    //         root
    // This combines all the intermediate transforms into a single one.
    MERGE_PREAGG_AGGREGATIONS = 11;

    // Parallel transforms are merged into single transforms.
    MERGE_TRANSFORMS = 8;

    // Maybe?
    MERGE_AGGREGATIONS_2 = 9;

    // The functional nodes are flattened by their equivalents.
    FUNCTIONAL_FLATTENING = 4;

    // Autocache requests are fullfilled.
    AUTOCACHE_FULLFILL = 5;

    // All the caching and uncaching requests are checked.
    CACHE_CHECK = 6;

    // If the compilation succeeds, this is corresponds to the final result.
    FINAL = 1000;
};


// An association between a global path and an internal id.
// This information could be kept strictly inside the brain, but this is the
// only piece of state there, and transfering it to the server makes the
// brain stateless (everything else is deterministic).
message NodeMapItem {
    NodeId node = 1;
    Path path = 2;
    ComputationId computation = 3;
    SessionId session = 4;
}

// A step in the compile transform.
message CompilerStep {
    CompilingPhase phase = 1;
    Graph graph = 2;
    // A representation of the graph that can be displayed with
    // TensorBoard.
    tensorflow.GraphDef graph_def = 3;
}


// ******** logging **********

enum MessageSeverity {

    INFO = 0;
    WARNING = 1;
    FATAL = 2;
}

message AnalysisMessage {
    ComputationId computation = 1;
    SessionId session = 2;
    NodeId relevant_id = 3;
    Path path = 4;
    string content = 5;
    MessageSeverity level = 6;
    string stack_trace_pretty = 7;
}

// ******* Communication with python (low level) *******

// A common error message for everything that comes out of the haskell side.
message ErrorMessage {
    message StackElement {
      string function = 1;
      string package = 2;
      string module = 3;
      string file = 4;
      int32 start_line = 5;
      int32 start_col = 6;
    }

    string message = 1;
    repeated StackElement hs_stack = 2;
    repeated string path = 3;
}

message NodeBuilderRequest {
    string op_name = 1;
    OpExtra extra = 2;
    repeated Node parents = 3;
    // The path that defines the scope of the node.
    // The full path of the created node will be prefixed
    // by this path.
    // Can be empty.
    Path requested_scope = 4;
}

message NodeBuilderResponse {
    ErrorMessage error = 1;
    Node success = 2;
}

message GraphTransformRequest {
    // The graph, with potentially some functional elements.
    Graph functional_graph = 3;
    // Nodes that have completed and are available for substitution.
    // repeated NodeMapItem available_nodes = 4;
    // The targets:
    repeated Path requested_paths = 5;
}

message GraphTransformResponse {
    // The graph, pinned to a device (if a success).
    Graph pinned_graph = 1;
    // Update of all the nodes that we know about.
    // repeated NodeMapItem node_map = 2;
    // Some information about the analysis
    repeated AnalysisMessage messages = 3;
    // The steps of the compiling transform.
    // They are returned in order.
    repeated CompilerStep steps = 4;
    ErrorMessage error = 5;

    // The actions to execute on the various backends.
    karps.spark.SparkGraph spark = 6;
}

