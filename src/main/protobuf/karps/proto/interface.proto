syntax = "proto3";

package karps.core;

import "karps/proto/graph.proto";
import "karps/proto/computation.proto";

service KarpsMain {
  rpc CreateSession (CreateSessionRequest) returns (CreateSessionResponse);

  // TODO: this is not necessary with the stream
  rpc CreateComputation (CreateComputationRequest) returns (CreateComputationResponse);

  // TODO: return a stream response too.
  rpc ComputationStatus (ComputationStatusRequest) returns (BatchComputationResult);

  rpc StreamCreateComputation (CreateComputationRequest) returns (stream ComputationStreamResponse);
  
  rpc ResourceStatus (ResourceStatusRequest) returns (ResourceStatusResponse);
  
};


message CreateSessionRequest {
  SessionId requested_session = 1;
};

message CreateSessionResponse {};

message CreateComputationRequest {
  SessionId session = 1;
  Graph graph = 3;
  ComputationId requested_computation = 4;
};

message CreateComputationResponse {};

message ComputationStatusRequest {
  SessionId session = 1;
  ComputationId computation = 2;
  repeated Path requested_paths = 3;
  
};

message ResourceStatusRequest {
  SessionId session = 1;
  repeated ResourcePath resources = 2;
};

message HdfsResourceStatus {
  ResourcePath path = 1;
  string error = 2;
  string return = 3;
}

message ResourceStatusResponse {
  repeated HdfsResourceStatus hdfs = 1;
};

message ComputationStreamResponse {
  SessionId session = 1;
  ComputationId computation = 2;
  oneof updates {
    Graph start_graph = 3;
    Graph pinned_graph = 4;
    // Returns all the most recent info on a node if anything changes for this node.
    // Not super efficient as the spark stats will be repeatedly sent over.
    BatchComputationResult results = 5;
  }
};