<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css" /><script type="text/javascript">window.onload = function(){var mathElements = document.getElementsByClassName("math");
  for (var i=0; i < mathElements.length; i++)
  {
   var texText = mathElements[i].firstChild
   katex.render(texText.data, mathElements[i])
  }}
  </script>
</head>
<body>
<hr />
<p>title: Pro Git author: Scott Chacon rights: Creative Commons Non-Commercial Share Alike 3.0 language: en-US</p>
<h1 id="a-formalism-for-data-systems">A formalism for data systems</h1>
<p>This is considerations for formalizing some ideas found in modern data systems.</p>
<p>The code examples are done using mathematical notations and Haskell functions, which should be clear enough in most of the case.</p>
<h2 id="general-principles">General principles</h2>
<p>Distribution of computation Representation is not observable</p>
<h2 id="setting">Setting</h2>
<p>We consider operations over some sets of values, in which we want to follow some basic principles. All the operations operate either on values or sets of values, and data processing consists in writing some functions that transform sets into other sets, or into values. Here are a couple of assumptions that we will work on: - the exact representation of the data is not observable. This is often not verified in such systems. - the data is considered static. It does not change over time.</p>
<p>The first point has profound implications, in that datasets do not have first or last elements. They do not behave like regular collections, which are usually sequential in nature. However, this provides a lot of advantages in the case of big data processing.</p>
<p>We consider here a simple formalism: call <span class="math inline">\mathcal{U}</span> the set of all the values, called the <em>universe</em>. We assume that the universe is countable and separable. Subsets of the set of all values can be tagged with <em>types</em>. A type is essentially a subset of all the values. Types are mostly useful when writing programs and for clarity, not so much for our mathematical derivations.</p>
<p>A dataset is a <em>finite measure</em> over the set of values. <span class="math inline">d:U\rightarrow\mathbb{N}</span> with the restriction: <span class="math display">\displaystyle 
\sum_{x\in\mathcal{U}}d\left(x\right)&lt;\infty
</span></p>
<p><strong>Note</strong> Basic set arithmetic ensures that the function defined above is a measure in the sense of distributions. In a sense, we consider here some easy subset of distributions.</p>
<h3 id="basic-operations-over-distributions">Basic operations over distributions:</h3>
<p><strong>Union</strong> The union of two datasets is straightforward:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">union ::</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a
(union d1 d2) x <span class="fu">=</span> d1 x <span class="fu">+</span> d2 x</code></pre></div>
<p>This operation is of course symmetric, associative, commutative and has a zero element (the empty set). This is the most important of all the general operations, because it conveys some useful structure over datasets (a monoid and a semi-group).</p>
<p><strong>Dirac</strong> The dirac of a dataset is the extraction of a single value at a given point. The name <code>dirac</code> comes from the theory of measures, which itself comes from physics.</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">dirac ::</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a
dirac x y <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">==</span> y <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></code></pre></div>
<p>One trivial consequence is the fact that a dataset is the (finite) sum of diracs. This fact will have its importance later.</p>
<p><strong>Mass</strong> The mass of a dataset is the count of all its points. The name sounds related to physics and we will see the intuition behind it later.</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">mass ::</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Nat</span></code></pre></div>
<h3 id="point-transforms">Point transforms</h3>
<p>With this structure, there is not much we can do so far, apart from querying the value of a dataset at various points. We are going to add many more operations now. One of the simplest and yet most effective ways to transform a dataset is to apply some operation to all its points.</p>
<p>We are going to add a twist to it though, relative to the distribution principle: if a dataset is splittable, we would like the transform to be splittable too:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> b
f (d1 <span class="dt">U</span> d2) <span class="fu">=</span> (f d1) <span class="dt">U</span> (f d2)</code></pre></div>
<p>It turns out that this adds a lot of structure to all the possible point transforms; in particular the transforms have to be automorphisms over the dataset monoid.</p>
<p><strong>Proposition: neutral element</strong>:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">f {} <span class="fu">=</span> {}</code></pre></div>
<p><strong>Proposition: characterization</strong>: All the point transforms can be uniquely characterized by their operations on elements. More precisely, by the point function:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">point_f ::</span> a <span class="ot">-&gt;</span> [b]</code></pre></div>
<p>(up to a permutation of the elements in the return list). TODO</p>
<p>The last proposition shows that the <em>only</em> valid transforms a fully described by what happens on each point, and that each point can only get mapped to a collection of other points. We can now fully qualify transforms about how many points they produce for each point: exactly one (mass-preserving), at most once (mass-shrinking) or arbitrary.</p>
<p><strong>Mass-preserving transform</strong> A mass-preserving transform obeys the following law: forall d, <code>mass (f d) == mass d</code></p>
<p>It is fully characterized by a function <code>point_f :: a -&gt; b</code>. Conversely, any such function defines a mass-preserving transform. This is the functiorial <code>fmap</code> that is familiar to functional programmers:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">map<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> b</code></pre></div>
<p><strong>Shrinking transform</strong> A mass-shrinking transform (or shrinking transform in short) reduces the mass of a dataset: <code>forall d, mass (f d) &lt;= mass d</code>. Similarly, it is fully characterized by its optional return on each point:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">mapMaybe ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> b</code></pre></div>
<h3 id="reductions">Reductions</h3>
<p>Reductions correspond to the action of taking a dataset and condensing its information into a single value. This is the second fundamental operation one can do on a dataset.</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">f ::</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> b</code></pre></div>
<p>Again, we would like this transform to obey some distribution principle: reducing a dataset to a single value should be done independently from the structure of the dataset, and it should be run in parallel if the dataset is the union of subsets. This is expressed through the following definition:</p>
<p><strong>Definition</strong> A reduction <code>f</code> is said to be monoidal, or universal, if there exists a function <code>+_f :: b -&gt; b -&gt; b</code> that obeys the following distributivity rule:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">f (d1 union d2) <span class="fu">=</span> (f d1) <span class="fu">+</span>_f (f d2)</code></pre></div>
<p>A monoidal reduction can be interpreted as carrying over through computations of the underlying structure of the dataset. It turns out that the property above is quite strong and imposes a lot of constraints on the definition of <code>+_f</code>:</p>
<p><strong>Monoid structure</strong> The relation <code>(Im f, +_f)</code> describes a monoid over <code>Im f</code>. The neutral element of this monoid is <code>f {}</code>.</p>
<p><strong>Characterization</strong> This morphism is fully described by the values of <code>f</code> over diracs and <code>{}</code>.</p>
<p><strong>Unicity</strong> This monoidal law is unique. TODO</p>
<p><strong>Composition</strong> This trivial property has important performance consequences: If <code>f1</code> and <code>f2</code> are both monoidal reductions, then <code>f1 &amp;&amp;&amp; f2</code> is also a monoidal reduction.</p>
<h3 id="reductions---examples">Reductions - examples</h3>
<p>Here are a couple of fundamental examples of reductions.</p>
<h3 id="joins">Joins</h3>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">join ::</span> <span class="dt">Dataset</span> (k, a) <span class="ot">-&gt;</span> <span class="dt">Dataset</span> (k, b) <span class="ot">-&gt;</span> <span class="dt">Dataset</span> (k, <span class="dt">Maybe</span> a, <span class="dt">Maybe</span> b)</code></pre></div>
<p>It follows some distributivity law, as we would expect:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">join (a1 <span class="dt">U</span> a2) b <span class="fu">==</span> (join a1 b) <span class="dt">U</span> (join a2 b)
join a b <span class="fu">=</span> join b a
mass (join a b) <span class="fu">==</span> max (mass (key a1 <span class="dt">U</span> key a2))</code></pre></div>
<p>TODO: is it enough to defin the union through axioms?</p>
<h3 id="groups">Groups</h3>
<p>A group corresponds to the notion that data points can somehow be associated together. It allows to express transforms on potentially many datasets all at once.</p>
<p><strong>Definition: group</strong> A group is a function from datasets to datasets:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Group</span> k v <span class="fu">=</span> k <span class="ot">-&gt;</span> <span class="dt">Dataset</span> v</code></pre></div>
<p>Of course, this is a very high-level definition, and we will see how it works out in practice. A practical implementation of a group may be done as follow, thanks to Currification: a group is the type <code>k -&gt; v -&gt; Nat</code>, or through Currying: <code>(k, v) -&gt; Nat</code>, which suggest an alternative representation for groups:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Group</span> k v <span class="fu">=</span> <span class="dt">Dataset</span> (k, v)</code></pre></div>
<p>We will use one representation or the other according to the situation.</p>
<p>Reductions over groups. Define the following operator:</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">shuffle ::</span> <span class="dt">Reduce</span> a b <span class="ot">-&gt;</span> <span class="dt">Group</span> k a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> (k, b)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell"><span class="ot">groupBy ::</span> (v <span class="ot">-&gt;</span> k) <span class="ot">-&gt;</span> <span class="dt">Dataset</span> v <span class="ot">-&gt;</span> <span class="dt">Group</span> k v</code></pre></div>
<p><strong>Distributivity of shuffle</strong></p>
<p>This distributivity law shows the power of the universal reductions.</p>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">shuffle f (g1 <span class="ot">`union`</span> g2) <span class="fu">=</span> map (<span class="fu">+</span>_f) (join (shuffle f g1) (shuffle f g2))</code></pre></div>
<h3 id="filter">Filter</h3>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">filter<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a <span class="ot">-&gt;</span> <span class="dt">Dataset</span> a</code></pre></div>
<p>This is a simple example of contraction.</p>
<h3 id="ordered-reductions">Ordered reductions</h3>
<pre><code>orderedReduce :: Ord a =&gt; Dataset (a, b) -&gt; [b]</code></pre>
<h3 id="canonical-representation">Canonical representation</h3>
<div class="sourceCode"><pre class="sourceCode hs"><code class="sourceCode haskell">shuffle count <span class="fu">.</span> groupBy id </code></pre></div>
<h3 id="indexing-and-counting">Indexing and counting</h3>
<p>Here are a couple of operations one can do to as substitutes for usual operations in SQL, using the basic transforms outlined above.</p>
<h3 id="substitutes-for-random-operations">Substitutes for random operations</h3>
</body>
</html>
